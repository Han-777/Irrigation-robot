# 整体方案

## Main 主机 (STM32H743XIH6)

[H743教程]([【学以致用，授人以渔】2024视频教程汇总，DSP第12期，ThreadX第9期，BSP驱动第30期，USB实战第5期，GUI实战第3期（2024-04-30） - STM32F429 - 硬汉嵌入式论坛 - Powered by Discuz! (armbbs.cn)](https://www.armbbs.cn/forum.php?mod=viewthread&tid=110519))

### 反客卡发板资源

A <u>0 1 2 3 4 5</u> 6 <u>7 8 9 10</u> （带下划线为**未作为其他外设**引脚使用）

特殊引脚 A0_C  A1_C C2_C C3_C ( Direct channels are connected to analog I/Os (PA0_C, PA1_C, PC2_C and PC3_C) to optimize ADC performance.)

B <u>0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15</u> 

C <u>1 2 3 4 5 6 7</u> 8 9 10 11 12 

D 2 <u>3 4 5 6 7 11 12 13</u> 

E <u>2 3 4 5 6</u>

G <u>9 11 12 13 14</u> 

H <u>7</u> 8 9 10 11 12 13 14 

I <u>0 1 2 3</u> 4 5 6 7 8 9





【

A <u>**0 1** **2 3** **4 5**</u> **6** <u>**7** **8** **9 10**</u> （带下划线为**未作为其他外设**引脚使用）

特殊引脚 A0_C  A1_C C2_C C3_C (ADC 引脚)

B <u>**0** **1** **2 3** **4** **5 6** **7** **8 9** **10 11** **12 13** **14 15**</u> 

C <u>**1 2 3 4 5** **6 7**</u> **8 9** **10 11** **12** 

D **2** <u>**3 4 5 6 7** **11 12 13**</u> 

E <u>**2 3 4 5 6**</u>

G <u>**9** **11 12 13** **14**</u> 

H **<u>7</u> 8 9 10 11** **12** **13 14** 

I **<u>0 1 2 3</u> 4 5 6 7** **8 9**



A6: TIM13_1 | A7 TIM14_1 | A8-A11 TIM1_1-4 | 

PB 2, 3, 14, 15 | PC 1, 2, 3, 4, 5 | PD3, 4, 5, 6, 7

PG 7,9,14 \| PA8,15 \| PB5,6,7\| PE5,6 \| PC0,9 \| PD4,7

### 串口引脚MAIN

|   USART   |      外设      |          TX          |          RX           |   备注   |
| :-------: | :------------: | :------------------: | :-------------------: | :------: |
|    1_     |      蓝牙      |         PA9          |         PA10          |          |
| ***2_***  | TFmini激光雷达 |         PA2          |          PA3          |   left   |
| ***3_***  |     openmv     |   PB10 (I2C2_SCL)    |    PB11(I2C2_SDA)     |          |
| ***4_***  | TFmini激光雷达 | **PC10** \| H13(CAN) | **PC11** \| H14 (CAN) |  right   |
| ***5_***  |   mpu陀螺仪    |         PC12         |          PD2          |          |
|    6_     |                |      C6/**G14**      |       C7/**G9**       |          |
| 虚拟串口_ |    MP3语音     |     PD6->**I8**      |     PG15->**I9**      | 需要测试 |
|     7     |                |                      |                       |          |
|     8     |                |                      |                       |          |

### 串口引脚SLABE

| USART |      外设      |          TX          |          RX           | 备注  |
| :---: | :------------: | :------------------: | :-------------------: | :---: |
|  1_   |                |         PA9          |         PA10          |       |
|  2_   |      蓝牙      |         PA2          |          PA3          | left  |
|  3_   |      mp3       |   PB10 (I2C2_SCL)    |    PB11(I2C2_SDA)     |       |
|  4_   | TFmini激光雷达 | **PC10** \| H13(CAN) | **PC11** \| H14 (CAN) | right |
|       |                |                      |                       |       |
|       |                |                      |                       |       |
|       |                |                      |                       |       |
|       |                |                      |                       |       |
|       |                |                      |                       |       |





### CAN

| CAN  | 外设 |                TX                 |                RX                 | 备注 |
| :--: | :--: | :-------------------------------: | :-------------------------------: | :--: |
| can2 |      |         **B6**(SCL) / B13         |           **B5** / B12            |      |
| can1 |      | **B9**(I2C1_SDA) / H13 (UART4-TX) | **B8**(I2C1_SCL) / H14 (USAR4-RX) |      |

**TIM**

|      TIM       |                                                              |                                         |
| :------------: | :----------------------------------------------------------: | :-------------------------------------: |
|     TIM1_      |                        **A8(ch1) \|**                        |             **高级定时器**              |
|      TIM2      |                         **A5(ETR)**                          |                                         |
|     TIM13_     |                         **A6(ch1)**                          |             **舵机1 (yaw)**             |
|     TIM14_     |                         **A7(ch1)**                          |           **舵机2（pitch）**            |
|     TIM5_      | **A0(ch1)** \| **A1(ch2)** \| **A4(ETR)** \| **H12(CH3)** \| **I0(CH4)** |                                         |
| TIM3 （0 1 4） |     **B4(CH1)** \| B5(CH2) \| **B0(CH3)** \| **B1(CH4)**     |                                         |
|   TIM4 （7）   |        B6(CH1) \| **B7(CH2)** \| D12(CH1) \| D13(CH2)        |                                         |
|     TIM12      |                     B14(CH1) \| B15(CH2)                     | 可以引出作为PWM引脚，同时给**灰度使用** |
|      TIM3      |                     C6(CH1) \| C7 (CH2)                      |                                         |
|      TIM8      |     C6(CH1) \| C7 (CH2) \| C8(CH3) \| C9(CH4) \| I3(ETR)     |             **高级定时器**              |
|     TIM15      |                      E5(CH1) \| E6(CH2)                      |                                         |



|   外设   |                             Pin                              |          备注           |
| :------: | :----------------------------------------------------------: | :---------------------: |
|   灰度   |    PB 2, 3, 14, 15 \| PC 1, 2, 3, 4, 5 \| PD3, 4, 5, 6, 7    |                         |
|   GPIO   | D11, 12, 13 \| E2, 3, 4 \| G11, 12, 13 \| H7, 8, 9, 10, 11, 13, 14 \| I1, 2, 4, 5, 6, 7 | H13和H14可能还用作UART4 |
|  光电L   |                              I3                              |          Left           |
|  光电R   |                              I4                              |          Right          |
| 光电喷头 |                              I5                              |          喷头           |
|   IIC    |               D12(I2C4_SCL) \| D13 (I2C4_SCL)                |      还用做普通io       |
|  继电器  |                            **I6**                            |                         |
|   beep   |                              I7                              |                         |
|          |                                                              |                         |
|          |                                                              |                         |
|          |                                                              |                         |
|          |                                                              |                         |
|          |                                                              |                         |
|          |                                                              |                         |
|          |                                                              |                         |
|          |                                                              |                         |
|          |                                                              |                         |
| 继电器？ |                         PB12 \| PB4                          |        好像没有         |
|          |                                                              |                         |

![image-20240704195614283](C:\Users\blue\AppData\Roaming\Typora\typora-user-images\image-20240704195614283.png)

![image-20240704195632883](C:\Users\blue\AppData\Roaming\Typora\typora-user-images\image-20240704195632883.png)

![image-20240704195645945](C:\Users\blue\AppData\Roaming\Typora\typora-user-images\image-20240704195645945.png)

![image-20240704195706162](C:\Users\blue\AppData\Roaming\Typora\typora-user-images\image-20240704195706162.png)

![image-20240704195717271](C:\Users\blue\AppData\Roaming\Typora\typora-user-images\image-20240704195717271.png)







# 注意事项

### 1. 时间设置

HSE_STARTUP:系统启动时间改长： 5000UL

![image-20240705180852643](C:\Users\blue\AppData\Roaming\Typora\typora-user-images\image-20240705180852643.png)

# Freertos

## Heaps 堆

共享内存，在其上实现内存的分配与释放

malloc free new delete

## Stacks 栈 (the core of rtos)

the process of function call: 

* link register will store the address of function in stacks

* call the function

## 任务状态

![image-20240724104542951](.\.assets\image-20240724104542951.png)

self: pass NULL, blocked: vDelay

- [ ]  Create **chassis task**, which should carry out following tasks:
  - [ ] 1.  Combining the information from gyro and adjust its attutide in real time ()
  - [ ] 2.  Turning to target direction properly at each corner
  - [ ] 3.  When watering command (or task which has higer priority)comes, the forward speed should be set to 0, but continuely corrects the direction (<u>vTaskSuspended(chassis)</u>)
- [ ]  Create **water task** , which should perform following tasks:
  - [ ] 1.  higher priority
  - [ ] 2.  be enable by left or right water flag (manage tasks: which encharge of enabling or disabling other tasks), then it will check the information from lidar, if the distance is inside the range,-> (<u>vTaskResume(chassis)</u> / create when getting flag)
  - [ ] 3.  
- [ ]  Create **Initialization task**, which should perform following tasks: ()
  - [ ] 1. Not calling vTaskSuspended until all inilization tasks have been initialized.
  - [ ] 2. It should be created lastly

> **初始化函数参考：**

<img src=".\.assets\image-20240724114012858.png" alt="image-20240724114012858" style="zoom: 67%;" />

> **任务内部创建函数参考：**

​	

# CAN

### 波特率计算

$$
Baud rate = can时钟频率/(prescalar*(1+time\,segment1+time\,segment2))
$$

在配置CAN通信的波特率时，时间段1（Time Segment 1）和时间段2（Time Segment 2）的比例设置是很重要的。根据CAN协议和常见的实践，这个比例通常遵循以下原则：

1. 采样点位置：
   - 采样点通常应该位于位时间的75%到80%处。
   - 采样点 = (1 + 时间段1) / (1 + 时间段1 + 时间段2)

2. 常见比例：
   - 一个常用的比例是 (时间段1 : 时间段2) = (3 : 1) 或 (4 : 1)
   - 例如，如果总时间量程为10，可以设置时间段1为6或7，时间段2为2或3

3. 具体设置：
   - 时间段1通常设置为位时间的60%-70%
   - 时间段2通常设置为位时间的20%-30%

4. 实际例子：
   - 如果总位时间为10个时间量程（TQ），可以设置：
     同步段 = 1 TQ
     时间段1 = 6 或 7 TQ
     时间段2 = 3 或 2 TQ

5. 调整考虑：
   - 较长的时间段1提高抗干扰能力
   - 较长的时间段2提高重同步能力

6. 灵活性：
   - 这个比例可以根据具体应用和网络条件进行微调
   - 在高速CAN网络中，可能需要更精确的设置

总之，时间段1和时间段2的比例应该在保证采样点位于75%-80%的同时，尽可能地增加时间段1的长度以提高抗干扰能力。常见的比例如3:1或4:1是个很好的起点，但可以根据实际需求进行调整。

Citations:
[1] https://www.st.com.cn/zh/microcontrollers-microprocessors/stm32h7-series.html
[2] https://www.st.com.cn/zh/microcontrollers-microprocessors/stm32h7-series/products.html
[3] https://www.cnblogs.com/armfly/p/10916105.html
[4] https://www.stmcu.com.cn/stm32h7
[5] https://doc.embedfire.com/mcu/stm32/f4/hal_general/zh/latest/doc/chapter16/chapter16.html

# Git flow

在Git Flow工作流中，删除release分支是一个常见的步骤。以下是为什么要删除release分支的原因以及相应的Git命令示例：

### 为什么要删除release分支

1. **避免混乱**：一旦release分支完成并合并到master和develop分支中，它的任务就完成了。保留它可能会导致混乱，因为它已经不再需要进一步的开发或维护。

2. **保持仓库整洁**：删除不再需要的分支有助于保持仓库的整洁和管理的简洁。这样可以减少分支的数量，便于开发人员在分支列表中找到正在进行的工作。

3. **防止误用**：保留已完成的release分支可能会导致开发人员误认为它仍然是活跃的分支，并在其上进行开发。删除它可以防止这种误用。

4. **版本管理**：通过删除release分支，可以确保每个版本都有一个明确的开始和结束点，有助于版本管理和回溯历史。

### Git命令示例

假设我们已经创建了一个release分支`release/1.3.0`，并且已经完成了所有的测试和修复工作。我们将它合并到`master`和`develop`分支后，可以删除该release分支。

1. **合并release分支到master和develop**：

```bash
# 切换到master分支
git checkout master

# 合并release分支到master
git merge --no-ff release/1.3.0

# 推送master分支到远程仓库
git push origin master

# 切换到develop分支
git checkout develop

# 合并release分支到develop
git merge --no-ff release/1.3.0

# 推送develop分支到远程仓库
git push origin develop
```

2. **添加版本标签（可选）**：

```bash
# 在master分支上添加标签
git checkout master
git tag -a v1.3.0 -m "Release version 1.3.0"

# 推送标签到远程仓库
git push origin v1.3.0
```

3. **删除release分支**：

```bash
# 删除本地release分支
git branch -d release/1.3.0

# 删除远程release分支
git push origin --delete release/1.3.0
```

通过这些步骤，我们可以确保release分支在完成其任务后被正确地删除，保持仓库的整洁和管理的简洁。

Citations:
[1] https://en.wikipedia.org/wiki/Direct_memory_access
[2] https://www.web.dma.mil/WEB-NextGen/
[3] https://www.stmcu.com.cn/Designresource/detail/LAT/710324
[4] https://dmaindustries.com
[5] https://commission.europa.eu/strategy-and-policy/priorities-2019-2024/europe-fit-digital-age/digital-markets-act-ensuring-fair-and-open-digital-markets_en



# bsp_can

<p align='right'>neozng1@hnu.edu.cn</p>

# 请注意使用 CAN 设备的时候务必保证总线只接入了 2 个终端电阻！开发板一般都有一个，6020 电机、c620/c610 电调、LK 电机也都有终端电阻，注意把多于 2 个的全部断开（通过拨码）

## 使用说明

若你希望新增一个基于 CAN 的 module，首先在该模块下应该有一个包含`can_instance`指针的 module 结构体（或当功能简单的时候，可以是单独存在的`can_instance`，但不推荐这样做）。

## 代码结构

.h 文件内包括了外部接口和类型定义,以及模块对应的宏。c 文件内为私有函数和外部接口的定义。

## 类型定义

```c

#define MX_REGISTER_DEVICE_CNT 12  // maximum number of device can be registered to CAN service, this number depends on the load of CAN bus.
#define MX_CAN_FILTER_CNT (4 * 14) // temporarily useless
#define DEVICE_CAN_CNT 2           // CAN1,CAN2

/* can instance typedef, every module registered to CAN should have this variable */
typedef struct _
{
    CAN_HandleTypeDef *can_handle; // can句柄
    CAN_TxHeaderTypeDef txconf;    // CAN报文发送配置
    uint32_t tx_id;                // 发送id
    uint32_t tx_mailbox;           // CAN消息填入的邮箱号
    uint8_t tx_buff[8];            // 发送缓存,发送消息长度可以通过CANSetDLC()设定,最大为8
    uint8_t rx_buff[8];            // 接收缓存,最大消息长度为8
    uint32_t rx_id;                // 接收id
    uint8_t rx_len;                // 接收长度,可能为0-8
    // 接收的回调函数,用于解析接收到的数据
    void (*can_module_callback)(struct _ *); // callback needs an instance to tell among registered ones
    void *id;                                // 使用can外设的模块指针(即id指向的模块拥有此can实例,是父子关系)
} CANInstance;

typedef struct
{
    CAN_HandleTypeDef* can_handle;
    uint32_t tx_id;
    uint32_t rx_id;
    void (*can_module_callback)(can_instance*);
    void* id;
} can_instance_config;

typedef void (*can_callback)(can_instance*);
```

- `MX_REGISTER_DEVICE_CNT`是最大的 CAN 设备注册数量，当每个设备的发送频率都较高时，设备过多会产生总线拥塞从而出现丢包和数据错误的情况。
- `MX_CAN_FILTER_CNT`是最大的 CAN 接收过滤器数量，两个 CAN 共享标号 0~27 共 28 个过滤器。这部分内容比较繁杂，暂时不用理解，有兴趣自行参考 MCU 的数据手册。当前为简单起见，每个过滤器只设置一组规则用于控制一个 id 的过滤。
- `DEVICE_CAN_CNT`是 MCU 拥有的 CAN 硬件数量。

- `can_instance`是一个 CAN 实例。注意，CAN 作为一个总线设备，一条总线上可以挂载多个设备，因此多个设备可以共享同一个 CAN 硬件。其成员变量包括发送 id，发送邮箱（不需要管，只是一个 32 位变量，CAN 收发器会自动设置其值），发送 buff 以及接收 buff，还有接收 id 和接收协议解析回调函数。**由于目前使用的设备每个数据帧的长度都是 8，因此收发 buff 长度暂时固定为 8**。定义该结构体的时候使用了一个技巧，使得在结构体内部可以用结构体自身的指针作为成员，即`can_module_callback`的定义。

- `can_instance_config`是用于初始化 CAN 实例的结构，在调用 CAN 实例的初始化函数时传入（下面介绍函数时详细介绍）。

- `can_module_callback()`是模块提供给 CAN 接收中断回调函数使用的协议解析函数指针。对于每个需要 CAN 的模块，需要定义一个这样的函数用于解包数据。
- 每个使用 CAN 外设的 module，都需要在其内部定义一个`can_instance*`。

## 外部接口

```c
void CANRegister(can_instance* instance, can_instance_config config);
void CANSetDLC(CANInstance *_instance, uint8_t length); // 设置发送帧的数据长度
uint8_t CANTransmit(can_instance* _instance, uint8_t timeout);
```

`CANRegister`是用于初始化 CAN 实例的接口，module 层的模块对象（也应当为一个结构体）内要包含一个`usart_instance`。调用时传入实例指针，以及用于初始化的 config。`CANRegister`应当在 module 的初始化函数内被调用，推荐 config 采用以下的方式定义，更加直观明了：

```c
can_instance_config config={.can_handle=&hcan1,
                            .tx_id=0x005,
                            .rx_id=0x200,
                            can_module_callback=MotorCallback}
```

`CANTransmit()`是通过模块通过其拥有的 CAN 实例发送数据的接口，调用时传入对应的 instance。在发送之前，应当给 instance 内的`send_buff`赋值。

## 私有函数和变量

在.c 文件内设为 static 的函数和变量

```c
static can_instance *instance[MX_REGISTER_DEVICE_CNT]={NULL};
```

这是 bsp 层管理所有 CAN 实例的入口。

```c
static void CANServiceInit()
static void CANAddFilter(can_instance *_instance)
static void CANFIFOxCallback(CAN_HandleTypeDef *_hcan, uint32_t fifox)
void HAL_CAN_RxFifo0MsgPendingCallback(CAN_HandleTypeDef *hcan)
void HAL_CAN_RxFifo1MsgPendingCallback(CAN_HandleTypeDef *hcan)
```

- `CANServiceInit()`会被`CANRegister()`调用，对 CAN 外设进行硬件初始化并开启接收中断和消息提醒。

- `CANAddFilter()`在每次使用`CANRegister()`的时候被调用，用于给当前注册的实例添加过滤器规则并设定处理对应`rx_id`的接收 FIFO。过滤器的作用是减小 CAN 收发器的压力，只接收符合过滤器规则的报文（否则不会产生接收中断）。

- `HAL_CAN_RxFifo0MsgPendingCallback()`和`HAL_CAN_RxFifo1MsgPendingCallback()`都是对 HAL 的 CAN 回调函数的重定义（原本的 callback 是`__week`修饰的弱定义），当发生 FIFO0 或 FIFO1 有新消息到达的时候，对应的 callback 会被调用。`CANFIFOxCallback()`随后被前两者调用，并根据接收 id 和硬件中断来源（哪一个 CAN 硬件，CAN1 还是 CAN2）调用对应的 instance 的回调函数进行协议解析。

- 当有一个模块注册了多个 can 实例时，通过`CANInstance.id`,使用强制类型转换将其转换成对应模块的实例指针，就可以对不同的模块实例进行回调处理了。

## 注意事项

由于 CAN 总线自带发送检测，如果总线上没有挂载目标设备（接收 id 和发送报文相同的设备），那么 CAN 邮箱会被占满而无法发送。在`CANTransmit()`中会对 CAN 邮箱是否已满进行`while(1)`检查。当超出`timeout`之后函数会返回零，说明发送失败。

由于卡在`while(1)`处不断检查邮箱是否空闲，调用`CANTransmit()`的任务可能无法按时挂起，导致任务定时不精确。建议在没有连接 CAN 进行调试时，按需注释掉有关 CAN 发送的代码部分，或设定一个较小的`timeout`值，防止对其他需要精确定时的任务产生影响。








##舵机的使用

<p align='left' >panrui@hnu.edu.cn</p>

> todo: 由于新增了 bsp_pwm 的支持,舵机模块需要部分重构

### 舵机基础知识

已最常见的 SG90 舵机为例，SG90 舵机要求工作在频率为 50HZ——周期为 20ms 的 PWM 波，且对应信号的高低电平在 0.5ms - 2.5ms 之间，对应的舵机转动角度如下表所示（当然也可以按照这个线性的对应关系去达到转动自己想要的角度，如想要转动 60°，则高电平脉宽为大概为 1.2ms，具体能不能转到特定的角度还和舵机的精度有关）

> 0.5ms-------------0 度； 2.5%
> 1.0ms------------45 度； 5.0%
> 1.5ms------------90 度； 7.5%
> 2.0ms-----------135 度； 10.0%
> 2.5ms-----------180 度； 12.5%

根据`<font color=black size=3>Tout = (PSC+1)* (ARR+1)/Tclk</font>`公式
则我们需要产生 50Hz 的 PWM 波，则预分频的系数为 Prescaler = 168-1，自动重装载值 Counter Period = 20000-1，此时定时器产生的频率为 168Mhz/168/20000 = 50Hz。 当然这个值也可以自己设置，只要满足产生的频率为 50Hz 即可.
`__HAL_TIM_SET_COMPARE(htim, Channel, compare_value);`
这是设置占空比的函数
eg：当初始占空比为 1200/20000 则为 6%，根据 20*6%=1.2ms （1.2-0.5）/(2.5-0.5)*180=63° 故舵机会转动 63°
为了方便通过上述 eg 我们将所需要的角度与 PWM 计数值对应关系封装成函数。需要在初始化的時候输入我们所需要的角度和相关定时器参数即可。这样我们就可以设置 SG90 为参数范围内(0~180°)任意度数。

---

## 如何注册一个舵机实例

!!!

**注意！由于舵机为开环控制，无论选择舵机为何种类型，舵机都能够正常运行，但是运行的角度可能会与设定不同，请务必正确选择舵机型号！且最多添加 7 个舵机！**
我们可以像这样注册一个舵机实例

```c

static ServoInstance *leftservomoto;
//初始化参数
Servo_Init_Config_s config={
    //舵机安装选择的定时器及通道
    //C板有常用的7路PWM输出:TIM1-1,2,3,4 TIM8-1,2,3
    .htim=&htim1,
    .Channel=TIM_CHANNEL_1,
    //舵机的初始化模式和类型
    .Servo_Angle_Type=Start_mode,
    .Servo_type=Servo180,
};
// 设置好参数后进行初始化并保留返回的指针
leftservomoto = ServoInit(&config);
```

> 要控制一个舵机 我们提供了以下三个接口

```c
//自由模式下，写入自由角度数值
void Servo_Motor_FreeAngle_Set(ServoInstance *Servo_Motor, int16_t S_angle);
//起止模式下，写入起始，终止角度数值(防止反复写入起始和终止角度)
void Servo_Motor_StartSTOP_Angle_Set(ServoInstance *Servo_Motor, int16_t Start_angle, int16_t Final_angle);
/*
    Free_Angle_mode, // 任意角度模式
    Start_mode,      // 起始角度模式
    Final_mode,      // 终止角度模式
*/
void Servo_Motor_Type_Select(ServoInstance *Servo_Motor,int16_t mode);
//比如我们要使用舵机，并更改一个舵机的模式
void ServoTask()
{
    //更改leftservomoto为Free_Angle_mode模式
    Servo_Motor_Type_Select(leftservomoto,Free_Angle_mode);
    //设置转到0角度
    Servo_Motor_FreeAngle_Set(leftservomoto, 0);
    //调用函数，控制电机
    Servo_Motor_Control();
}


```







# can_comm

<p align='right'>neozng1@hnu.edu.cn</p>

> TODO:
>
> 1. 对`CANCommGet()`进行修改，使得其可以返回数据是否更新的相关信息。

## 重要提醒

如果传输过程中出现多次丢包或长度校验不通过，尤其是传输长度较大的时候，请开启CAN的Auto Retransmission，并尝试修改CANComm实例的发送和接受ID（以提高在总线仲裁中的优先级）。

## 总览和封装说明

CAN comm是用于CAN多机通信的模块。你不需要关心实现的协议，**只需要传入你想发送/接收的结构体的长度**（通过`sizeof()`获取）即可。单帧发送长度目前限制为60字节，如果需要加长可以在`can_comm.h`中修改`CAN_COMM_MAX_BUFFSIZE`的定义值。注意CAN的负载以及使用此模块的发送频率，否则可能造成堵塞。

## 代码结构

.h中放置的是数据定义和外部接口，以及协议的定义和宏，.c中包含一些私有函数。

## 外部接口

```c
CANCommInstance *CANCommInit(CANComm_Init_Config_s* comm_config);
void CANCommSend(CANCommInstance *instance, uint8_t *data);
void *CANCommGet(CANCommInstance *instance);
uint8_t CANCommIsOnline(CANCommInstance *instance);
```

第一个函数将会初始化一个CANComm实例，返回其指针。使用CANComm进行通信的应用应该保存返回的指针。初始化需要传入一个初始化结构体。请在应用初始化的时候调用该函数。推荐的结构体配置方式如下：

```c
/* 初始化结构体的定义 */
typedef struct
{
    can_instance_config_s can_config;
    uint8_t send_data_len; //发送数据长度
    uint8_t recv_data_len; //接收数据长度,两者请用sizeof获取
} CANComm_Init_Config_s;

CANComm_Init_Config_s cconfig = {
  .can_config = {
            .can_handle=&hcan1,
            .tx_id=0x02,
            .rx_id=0x03},
  .send_data_len = sizeof(your_data_structure),
  .recv_data_len = sizeof(recv_data_structure)
};
```

第二个函数将会通过CAN发送一帧数据。这里的“帧”不是CAN的一帧报文，而是你使用的数据。在CANComm初始化的时候，使用sizeof获得你要发送的数据的长度。调用此函数时，将你的数据结构或数据cast成`u8`类型的指针传入即可。==**特别注意，你的结构体需要使用预编译指令`#pragma pack(1)`以及`#pragma pack()`包裹**==，从而进行字节压缩而不进行字节对齐，如：

```c
#pragma pack(1)
typedef struct
{
    uint8_t aa;
    float bb;
    double cc;
    uint16_t dd;
} some_struct;
#pragma pack()
```

只有这样，这个结构体才不会进行padding扩充字节实现字节对齐。你可以尝试一下，如果不使用pack处理，上面的结构体将会占据18个字节以上的空间；开启pack后，会降低至15。更多关于字节对齐的内容，自行查询。

> 后期可能更新字节对齐和内存访问相关的教程。

`CANCommGet()`是获取来自CANComm接收到的数据的接口，返回值为一个void类型指针，你需要通过**强制类型转换**将其变为你设定的接收类型指针，然后就可以访问其数据了。

## 私有函数和变量

```c
static CANCommInstance *can_comm_instance[MX_CAN_COMM_COUNT] = {NULL};
static uint8_t idx; 
static void CANCommResetRx(CANCommInstance *ins);
static void CANCommRxCallback(can_instance *_instance);
```

第一个指针数组保存所有的can comm实例，从而在callback中区分不同实例。idx是初始化使用的索引，用于确定每个can comm实例指针存放的位置。

`CANCommResetRx()`在`CANCommRxCallback()`中多次被调用，用于清空接收缓冲区。

`CANCommRxCallback()`是CAN comm初始化can实例时的回调函数，用于can接收中断，进行协议解析。

## 使用范例

例如，这里要发送的数据是一个float，接收的数据是如下的`struct`，**==注意要使用pack==**：

```c
#pragma pack(1)
struct test
{
 float aa;
 float bb;
 float cc;
 uint16_t dd;
};
#pragma pack()
```

初始化时设置如下：

```c
CANComm_Init_Config_s cconfig = {
  .can_config = {
            .can_handle=&hcan1,
            .tx_id=0x02,
            .rx_id=0x03},
  .send_data_len = sizeof(float),
  .recv_data_len = sizeof(struct test)
};
CANCommInstance* ins = CANCommInit(&cconfig);
```

通过`CANCommGet()`并使用强制类型转换获得接收到的数据指针：

```c
struct test* data_ptr=(struct test*)CANCommGet(ins)
```

发送通过`CANCommSend()`，建议使用强制类型转换：

```c
float tx=114.514;
CANCommSend(ins, (uint8_t*)&tx);
```

## 接收解析流程

CAN comm的通信协议如下：

| 帧头        | 数据长度 | 数据             | crc8校验 | 帧尾        |
| ----------- | -------- | ---------------- | -------- | ----------- |
| 's'（0x73） | 0~255    | 最大60（可修改） | 校验码   | 'e'（0x65） |
| 1-byte      | 1-byte   | n-byte           | 1-byte   | 1-byte      |

接收的流程见代码注释。

流程图如下：![未命名文件](../../.assets/CANcomm.png)

